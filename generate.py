import pickle
import numpy as np
from music21 import note, stream, chord
from util import prepare_sequences, convert_to_float
from model import create_network


NUM_GENERATE = 128
FILEPATH = "outputs/e500-lofi_output_1_"


def generate(num_generate):
    print("Generating", num_generate, "tracks...")
    # load the notes used to train the model
    with open('data/notes', 'rb') as filepath:
        notes = pickle.load(filepath)
    # Get all pitch names and vocab size
    pitch_names = sorted(set(item for item in notes))
    n_vocab = len(set(notes))
    network_input, normalized_input, _ = prepare_sequences(notes, pitch_names, n_vocab)
    # generate sequential predictions given previous sequences
    model = create_network(normalized_input, n_vocab)

    for ind in range(num_generate):
        print("Track", ind + 1, "generating...")
        prediction_output = generate_notes(model, network_input, pitch_names, n_vocab)
        create_midi(prediction_output, ind)
        print("Track", ind + 1, "generated.")
    print("All tracks generated!")


def generate_notes(model, network_input, pitch_names, n_vocab):
    # pick a random sequence from the input as a starting point for the prediction
    start = np.random.randint(0, len(network_input) - 1)
    pattern = network_input[start]
    prediction_output = []
    int_to_note = dict((number, pitch) for number, pitch in enumerate(pitch_names))

    # generate NUM_GENERATE notes
    for note_index in range(NUM_GENERATE):
        prediction_input = np.reshape(pattern, (1, len(pattern), 1))
        prediction_input = prediction_input / float(n_vocab)

        prediction = model.predict(prediction_input, verbose=0)

        ind = np.argmax(prediction)
        result = int_to_note[ind]
        prediction_output.append(result)

        pattern = np.append(pattern, ind)
        pattern = pattern[1:len(pattern)]

    return prediction_output


def create_midi(prediction_output, ind):
    """ convert the output from the prediction to notes and create a midi file
        from the notes """
    offset = 0
    output_notes = []

    # create note, chord, and rest objects based on the values generated by the model
    for pattern in prediction_output:
        split = pattern.split()
        length = convert_to_float(split[-1])
        # reduce length of longer notes to emphasize melody.
        if length >= 2:
            length /= 2
        # pattern is a chord
        if ('.' in split[0]) or split[0].isdigit():
            notes_in_chord = split[0].split('.')
            notes = []
            for current_note in notes_in_chord:
                new_note = note.Note(int(current_note))
                notes.append(new_note)
            new_chord = chord.Chord(notes)
            new_chord.duration.quarterLength = length
            new_chord.offset = offset
            output_notes.append(new_chord)
        # pattern is a rest
        # elif split[0] == "Rest":
        #     new_rest = note.Rest()
        #     new_rest.duration.quarterLength = length
        #     new_rest.offset = offset
        #     output_notes.append(new_rest)
        # pattern is a note
        else:
            new_note = note.Note(split[0])
            new_note.duration.quarterLength = length / 2
            new_note.offset = offset
            output_notes.append(new_note)
        # increase offset each iteration so that notes do not stack
        offset += length
    midi_stream = stream.Stream(output_notes)
    midi_stream.write('midi', fp=FILEPATH + str(ind + 1) + ".mid")


if __name__ == '__main__':
    generate(5)
